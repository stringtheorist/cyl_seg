#ifndef CYLINDRICAL_MODEL_H
#define CYLINDRICAL_MODEL_H

#include <pcl/ModelCoefficients.h>
#include <pcl/io/pcd_io.h>
#include <pcl/point_types.h>
#include <pcl/filters/extract_indices.h>
#include <pcl/filters/passthrough.h>
#include <pcl/features/normal_3d.h>
#include <pcl/sample_consensus/method_types.h>
#include <pcl/sample_consensus/model_types.h>
#include <pcl/segmentation/sac_segmentation.h>
#include <iostream>
#include <boost/thread/thread.hpp>
#include <pcl/common/common_headers.h>
#include <pcl/features/normal_3d.h>
#include <pcl/io/pcd_io.h>
#include <pcl/console/parse.h>

typedef pcl::PointXYZ PointT;

/* Simple class that encapsulates all the data involved in performing cylinder segmentation
 * All intermediate point clouds and index before and after filtering are stored
 *
 * All data members are public in order to facilitate quick testing and experimentation. This 
 * is done intentionally in contravention of good production programming practice in this case
 * as the code is experimental in nature. 
 * 
 * IMPORTANT: The member functions of the class *must* be called in the order 1. buildPassThroughFilter()
 * 2. estmatePointNormals() 3. segmentPlanar() 4.segmentCylinder() as each member in that order 
 * depends on data generated by the previous ones.*/
class CylindricalModel 
{
    public:

	//Parameters for cylinder segmentation
	float filter_distance;
	int K;
	float normal_dist_wt;
	float threshold_planar;
	float threshold_cylinder;
	int maxit_planar;
	int maxit_cylinder;
	float radius_limit;

	//All objects needed
	pcl::PCDReader reader;
	pcl::PassThrough<PointT> pass;
	pcl::NormalEstimation<PointT, pcl::Normal> ne;
	pcl::SACSegmentationFromNormals<PointT, pcl::Normal> seg; 
	pcl::PCDWriter writer;
	pcl::ExtractIndices<PointT> extract;
	pcl::ExtractIndices<pcl::Normal> extract_normals;
	pcl::search::KdTree<PointT>::Ptr tree;

	// Datasets
	pcl::PointCloud<PointT>::Ptr cloud;
	pcl::PointCloud<PointT>::Ptr cloud_filtered;
	pcl::PointCloud<pcl::Normal>::Ptr cloud_normals;
	pcl::PointCloud<PointT>::Ptr cloud_filtered_nonplane;
	pcl::PointCloud<pcl::Normal>::Ptr cloud_normals_nonplane;
	pcl::ModelCoefficients::Ptr coefficients_plane; 
	pcl::ModelCoefficients::Ptr coefficients_cylinder;
	pcl::PointIndices::Ptr inliers_plane;
	pcl::PointIndices::Ptr inliers_cylinder;
	pcl::PointCloud<PointT>::Ptr cloud_plane;
	pcl::PointCloud<PointT>::Ptr cloud_cylinder;

	//Constructor initializes all data members
	//    CylindricalModel(double filter_distance_, int K_, double normal_dist_wt_, double threshold_planar_, 
	//	double threshold_cylinder_, int maxit_planar_, int maxit_cylinder_, double radius_limit_); 
	//
	CylindricalModel(float filter_distance_, int K_, float normal_dist_wt_, float threshold_planar_, 
		float threshold_cylinder_, int maxit_planar_, int maxit_cylinder_, float radius_limit_); 

	//simple wrapper to read in the initial point cloud
	void readInCloudData(char *filename);

	//performs operation to build and apply a pass through filter to 
	//remove NaNs from the input cloud
	void buildPassThroughFilter(void);

	//performs operations to estimate point normals, should be called after calling
	//buildPassThroughFilter()
	void estimatePointNormals(void);


	//performs operations to do planar segmentation, should be called after calling 
	//estimatePointNormals() as it requires point normal data.
	void segmentPlanar(void);

	//writes cloud_plane to disk. Will fail with output to std::cerr if the cloud is empty. Eg if
	//planar segmentation fails or segmentPlanar() has not been called or has failed. 
	void writePlanarModel(char *filename);

	//performs operations to do cylinder segmentation, should be called after calling 
	//segmentPlanar
	void segmentCylinder(void);

	//writes cloud_cylinder to disk. Will fail with output to std::cerr if the cloud is empty. Eg if
	//cylinder segmentation fails or segmentCylinder() has not been called or has failed.
	void writeCylindricalModel(char *filename);
};

#endif
